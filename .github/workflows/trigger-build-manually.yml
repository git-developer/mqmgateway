name: Manually trigger Build and Publish
run-name: Build and publish to ${{ inputs.registry }}

on:
  # note: workflow_dispatch requires this workflow file to be on the default branch
  workflow_dispatch:
    inputs:
      registry:
        description: 'Target registry'
        type: choice
        options:
          - GitHub Container Registry
          - Docker Hub
        default: GitHub Container Registry
      platforms:
        description: 'Target platforms in JSON list syntax'
        default: '[ "linux/amd64", "linux/arm/v6", "linux/arm/v7", "linux/arm64", "linux/i386" ]'
      BUILD_ARG_ALPINE_VERSION:
        description: 'Version of Alpine Linux base image'
        default: latest
      BUILD_ARG_EXPRTK_UTL:
        description: 'URL to exprtk header file'
        default: 'https://github.com/ArashPartow/exprtk/raw/master/exprtk.hpp'
      BUILD_ARG_MQM_TEST_SKIP:
        description: 'Skip tests?'
        type: boolean
        default: false
      BUILD_ARG_MQM_TEST_ALLOW_FAILURE:
        description: 'Continue build if tests fail?'
        type: boolean
        default: false
      BUILD_ARG_MQM_TEST_DEFAULT_WAIT_MS:
        description: 'Timeout for tests (in ms)'
        type: number
        default: 400
      BUILD_ARG_MQM_TEST_LOGLEVEL:
        description: 'Log level for tests (1-5, higher is more verbose)'
        type: choice
        options: [ 1, 2, 3, 4, 5 ]
        default: 3

jobs:
  inputs-to-array:
    runs-on: ubuntu-latest
    env:
      PREFIX: 'BUILD_ARG_'
      INPUTS: ${{ toJSON(inputs) }}
    outputs:
      result: ${{ steps.run-script.outputs.result }}
    steps:
      - uses: actions/github-script@v6
        id: run-script
        with:
          script: |
            const prefix = process.env.PREFIX;
            return JSON.stringify(Object.entries(JSON.parse(process.env.INPUTS))
              .filter(([key, value]) => key.startsWith(prefix))
              .map(([key, value]) => key.replace(prefix, '').concat('=', value)));

  prepare:
    runs-on: ubuntu-latest
    outputs:
      build-args: ${{ steps.collect-build-args-json.outputs.result }}
      build-args-multiline: ${{ steps.collect-build-args-multiline.outputs.result }}
    env:
      BUILD_ARG_ALPINE_VERSION: ${{ inputs.alpine-version }}
      BUILD_ARG_EXPRTK_URL: ${{ inputs.exprtk-url }}
      BUILD_ARG_MQM_TEST_SKIP: ${{ inputs.test-skip }}
      BUILD_ARG_MQM_TEST_ALLOW_FAILURE: ${{ inputs.test-allow-failure }}
      BUILD_ARG_MQM_TEST_DEFAULT_WAIT_MS: ${{ inputs.test-timeout }}
      BUILD_ARG_MQM_TEST_LOGLEVEL: ${{ inputs.test-loglevel }}
    steps:
      - id: collect-build-args-json
        run: |
          {
            printf result=
            printf '['
            sep=''
            printenv | sed -nE 's/^BUILD_ARG_(.+)$/\1/p' | while read -r arg; do
              printf '%s"%s"' "${sep}" "${arg}"
              sep=", "
            done
            printf ']'
          } >>"${GITHUB_OUTPUT}"
      - id: collect-build-args-multiline
        run: |
          {
            echo 'result<<EOF'
            printenv | sed -nE 's/^BUILD_ARG_(.+)$/\1/p'
            echo EOF
          } >> "${GITHUB_OUTPUT}"

  build-multi-platform-to-ghcr:
    if: inputs.registry == 'GitHub Container Registry'
    permissions:
      packages: write
    uses: ./.github/workflows/build-ghcr.yml
    needs: inputs-to-array
    with:
      platforms:      ${{ inputs.platforms }}
      build-args:     ${{ needs.inputs-to-array.outputs.result }}

  build-multi-platform-to-dockerhub:
    if: inputs.registry == 'Docker Hub'
    uses: ./.github/workflows/build-dockerhub.yml
    needs: inputs-to-array
    with:
      platforms:      ${{ inputs.platforms }}
      build-args:     ${{ needs.inputs-to-array.outputs.result }}
